# **Hashable**
  - Документация от эпл даёт такое определение:"Тип, который может быть хэширован в Hasher для получения целочисленного значения хэша."
  - К примеру, ключ для типа данных **Dictionary** должен конформить протокол Hashable, аналогично и для элементов типа данных **Set**.
    - @frozen struct Dictionary<Key, Value> where Key : Hashable
    - @frozen struct Set<Element> where Element : Hashable
#
  Однако неясно, что делает эти типы данных Hashable? И как мы можем сделать наши собственные типы данных Hashable?
  
  **Хеширование - что и почему?**
  
  Когда мы говорим о хэше, то часто слышим такие понятия: хэш, хеширование, хеш-код, хеш-значение, хеш-таблицу и хеш-функцию. Даже если мы не знакомы со всеми этими терминами, мы используем их в различных языках программирования.
  
  **Основные понятия**
  - Хеширование - процесс применения алгоритма для преобразования элемента данных в значение. Элемент данных может быть таким же простым, как целое число, строка или сложным, как объект с несколькими свойствами.
  - Алгоритм называется хеш-функцией или хешером. Преобразованное значение называется хэш-значением, хэш-кодом или просто хэшем.
  ![image](https://user-images.githubusercontent.com/47610132/163712147-8091e68a-7848-4f8f-bcab-978373d8c0e0.png)
  
    - На приведенной выше схеме показан упрощенный пример процесса хеширования. По существу, мы начинаем с четырех видов фруктов (то есть элементов данных) в левой части.
Алгоритм (то есть хеш-функция) может преобразовывать эти четыре имени как входные в четыре целых числа (то есть значения хеш-функции) как выходные в правой части, которые выглядят как случайные числа без очевидной связи с их исходными входами.
  
  Важно отметить:
  - **Процесс хеширования должен быть повторяемым.** Хеш-функция должна всегда создавать одно и то же хеш-значение, если она подается с теми же данными. Каждый раз, когда мы запрашиваем хеш-значение, первого элемента на диаграме - Apple, хеш-функция надежно вернет нам **839021**.
  - **Значения хэша должны быть уникальными.** Apple, Orange, Peach и Pineapple сопоставляются с различными значениями хэша, когда мы просим хеш-функцию вычислить новый фрукт, скажем Клубника, функция может дать значение, такое как **542381**, которое, как ожидается, будет отличаться от существующих на диаграмме.
  - **Хеш-значения должны быть кажущимися случайными.** Используя более технический жаргон, хэш-значения не должны быть легко инвертированы, чтобы узнать, каковы исходные элементы данных. Таким образом, хеш-значения должны выглядеть случайными, чтобы минимизировать возможность инверсии.
  - **Значения хэша не обязательно должны быть положительными целыми числами.** Диаграмма использует целые числа в качестве значений хэша только в демонстрационных целях. Хеш-функция определяет вывод (т.е. значения хеш-функции) и, таким образом, в зависимости от самой хеш-функции, значения хеш-функции могут быть отрицательными целыми числами, и они также могут содержать цифры, буквы и даже символы.
  
  #
  **Примеры использования**
  
Хеширование широко используется в различных аспектах нашей повседневной жизни.
Чтобы лучше понять хеширование, давайте разберём три распространенных случая использования хеширования в операциях с базами данных, криптографии и структурах данных в программировании:
  
  - **Операция базы данных: поиск**
  
  Практически все веб-сайты и мобильные приложения имеют функцию поиска где-то в своих приложениях. Реализация функции поиска предполагает использование хеширования. Предположим, что в таблице базы данных имеется список локальных малых предприятий. Как - то раз вы захотели сделать технический осмотр вашего автомобился и решили обратиться в John's Mechanic.
![image](https://user-images.githubusercontent.com/47610132/163714589-50833c76-0d72-4f49-96ac-940421087d10.png)
  
  - **Без использования хеширования:**
    - При поиске в этой таблице с использованием имени магазина база данных должна сравнить эту 15-символьную строку с полем имени компании для каждой записи.
Представьте, что количество записей может составлять сотни тысяч, так что этот процесс может быть очень длительным и недостаточно эффективным, так же сложность по времени функции поиска является O (n), что означает, что необходимое время линейно пропорционально размеру данных.

  - **С использованием хеширования:**
    - Каким-то образом владелец базы данных усвоил хитрость хеширования и использовал хеш-функцию для создания уникальных хеш-значений для каждого из предприятий и использовал их в качестве индекса для всех этих предприятий.
Теперь при выполнении запроса поиска с использованием имени хранилища John's Mechanic база данных сначала будет использовать хеш-функцию для вычисления значения хеш-функции для критерия поиска.
Как упоминалось ранее, ожидается, что хеш-функция создаст одно и то же хеш-значение для того же хранилища, так что мы просто рассмотрим индекс и выясним, где находится запись данных.
В среднем, временная сложностью функции поиска с использованием хеширования является O (1) - постоянное количество времени, не зависящее от размера данных.
  ![image](https://user-images.githubusercontent.com/47610132/163714918-f8cbba40-ea7e-44fb-85e3-28c578be32b8.png)
  
  #
  **Криптография: пароль**
  Для обеспечения персональной работы, многие веб-сайты и приложения требуют от пользователей создания собственных учетных записей. В процессе регистрации мы обычно предоставляем свой адрес электронной почты и пароль для новой учетной записи на веб-сайте. Эти два фрагмента текста будут отправлены через Интернет до того, как они поступят на сервер.

  - **Без использования хеширования:**
 Разработчики сайта ничего не знали о хешировании, и думали, что кибербезопасность их не волнует, таким образом, запрос на регистрацию был разработан для отправки посредством обычного текста. Он имеет значительный риск для безопасности данных. Если запрос перехватят, то пароль будет украден,т.к это просто обычный текст.
  
  - **С использованием хеширования:**
  При использовании хеширования, пароль будет хэширован на случайное текстовое значение, а если запрос на регистрацию перехватят, то будет открыт только этот хэшированный пароль. Как упоминалось выше, мы обычно разрабатываем хеш-функции, которые делают практически невозможным инвертирование хеш-значений в их исходные элементы данных. Таким образом, это более безопасный подход. База данных веб-сайта может просто хранить этот хэшированный пароль.
Когда мы попытаемся войти в систему, веб-сайт просто сравни предоставленный пароль (опять же, хэшированный) с сохраненным хэшированным паролем, потому что они должны быть такими же, как и входные данные (т.е. правильный пароль в обычном тексте) идентичны.
  ![image](https://user-images.githubusercontent.com/47610132/163715251-e1c17cc7-9e0e-4920-bf7f-a01395535ca2.png)
  
  #
  **Структура данных - Словарь**
  
Большинство языков программирования содержат в себе такой тип данных как словарь - неупорядоченная коллекция пар ключ - значение. Здесь мы не будем смотреть на детальную реализацию словаря, а затронем его хеш-таблицу, которая обеспечивает быстрый доступ к своим записям.
  
  - Для каждого ключа, хеш-функция вычисляет хеш-значение как индекс хранения этого элемента данных. Когда мы извлекаем элемент данных, программа вычисляет хеш-значение для предоставленного ключа и ищет индекс, если ключ с таким же хеш-значением существует. В этом случае возвращается соответствующий элемент данных. Если нет, будет возвращен nil. Поэтому тип данных, возвращаемый словарем, является необязательным, так как доступность не гарантируется.
  - Когда мы вставляем новую пару ключ-значение, хеш-функция просто вычисляет хеш-значение для ключа в качестве индекса для этого элемента данных, в то время как мы удаляем пару ключ-значение, мы просто удаляем индекс, который вычисляется из хеш-значения.
#
**Hashable Protocol**
  После общего понимания хеширования теперь мы можем сузить нашу область, сосредоточившись на протоколе Hashable в стандартной библиотеке Swift.
При обращении к странице документации по протоколу Hashable выясняется, что определение Hashable таково: `“A type that can be hashed into a Hasher to produce an integer hash value.”`
  
  Определение очень четкое, и мы можем определить три ключевых слова в этом определении: Тип, Hasher и Целочисленное значение, а теперь давайте рассмотрим их детальнее.
  
 #
  **Тип**
  
  Как упоминалось выше, все элементы в типе данных **Set(множества)** должны быть хэшируемыми. На поверхности это просто означает, что каждый отдельный элемент является хэшируемым, однако фактически означает - что конкретный тип этого дженерика **Set** должен соответствовать протоколу **Hashable**. Другими словами, **Hashable** как и другие протоколы реализуется на уровне типа, например - класс, структура, так что все его экземпляры являются хэшируемыми.
Кроме того, тип не только включает стандартные типы данных, такие как примитивы - целые числа, строки, но также включает свои собственные, пользовательские типы, пример будет ниже.
  
![image](https://user-images.githubusercontent.com/47610132/163717427-b98fc088-fc27-4b42-abf0-9a2ae786df09.png)

Важно отметить, что мы не вызываем метод **finalize** в методе **hash(into:)** потому-что компилятор автоматически завершит вычисление, вызвав метод **finalize** с помощью кода в **hashValue**, когда необходимо значение hash.

#
**Дополнительный материал:**
  - https://swiftrocks.com/how-hashable-works-in-swift
